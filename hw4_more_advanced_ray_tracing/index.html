<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="../stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../stylesheets/pygment_trac.css" media="screen">

    <title>ComputerGraphics by angiebird</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>ComputerGraphics</h1>
        <h2></h2>

        <section id="downloads">
          <a href="https://github.com/angiebird/ComputerGraphics/zipball/master" class="btn">Download as .zip</a>
          <a href="https://github.com/angiebird/ComputerGraphics/tarball/master" class="btn">Download as .tar.gz</a>
          <a href="https://github.com/angiebird/ComputerGraphics" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>
<script src=lib1.js></script>

<div class="container">
    <h2>Rotate Me</h2>
    <div>
<canvas id='canvas1' width=600 height=600></canvas>
</div>
</div>

<script id='my_vertex_shader' type='x-shader/x-vertex'>
   attribute vec3 aPosition;
   varying   vec3 vPosition;
   void main() {
      gl_Position = vec4(aPosition, 1.0);
      vPosition = aPosition;
   }
</script>

<script id='my_fragment_shader' type='x-shader/x-fragment'>
   precision mediump float;
   uniform float uTime;
   uniform float uF;
   uniform vec3  uCursor;

   #define tranSphereNum (1)
   uniform vec4 uTranSphere[tranSphereNum];
   float refracRate = 1.5;
   vec3 outPoint;
   vec3 outDir;
   float outT;

   #define interSphereNum (4)
   uniform vec4 uInterSphere[interSphereNum];
   vec3 uInterSphereMatreal;

   varying vec3  vPosition;

   #define sphereNum (1)
   uniform vec4  uSphere[sphereNum];
   vec3 materialSphere[sphereNum];

    vec3 materialInterSphere[interSphereNum];

   #define planeNum (1)
   vec4 plane[planeNum];
   vec3 materialPlane[planeNum];

   vec3 Lrgb;
   vec3 Ldir;

   // ray tracing data
   vec3 rtMaterial;
   vec3 rtPoint;
   vec3 rtNormal;
   float rtT;

vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
vec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }

float noise(vec3 P) {
   vec3 i0 = mod289(floor(P)), i1 = mod289(i0 + vec3(1.0));
   vec3 f0 = fract(P), f1 = f0 - vec3(1.0), f = fade(f0);
   vec4 ix = vec4(i0.x, i1.x, i0.x, i1.x), iy = vec4(i0.yy, i1.yy);
   vec4 iz0 = i0.zzzz, iz1 = i1.zzzz;
   vec4 ixy = permute(permute(ix) + iy), ixy0 = permute(ixy + iz0), ixy1 = permute(ixy + iz1);
   vec4 gx0 = ixy0 * (1.0 / 7.0), gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
   vec4 gx1 = ixy1 * (1.0 / 7.0), gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
   gx0 = fract(gx0); gx1 = fract(gx1);
   vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0), sz0 = step(gz0, vec4(0.0));
   vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1), sz1 = step(gz1, vec4(0.0));
   gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5);
   gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5);
   vec3 g0 = vec3(gx0.x,gy0.x,gz0.x), g1 = vec3(gx0.y,gy0.y,gz0.y),
        g2 = vec3(gx0.z,gy0.z,gz0.z), g3 = vec3(gx0.w,gy0.w,gz0.w),
        g4 = vec3(gx1.x,gy1.x,gz1.x), g5 = vec3(gx1.y,gy1.y,gz1.y),
        g6 = vec3(gx1.z,gy1.z,gz1.z), g7 = vec3(gx1.w,gy1.w,gz1.w);
   vec4 norm0 = taylorInvSqrt(vec4(dot(g0,g0), dot(g2,g2), dot(g1,g1), dot(g3,g3)));
   vec4 norm1 = taylorInvSqrt(vec4(dot(g4,g4), dot(g6,g6), dot(g5,g5), dot(g7,g7)));
   g0 *= norm0.x; g2 *= norm0.y; g1 *= norm0.z; g3 *= norm0.w;
   g4 *= norm1.x; g6 *= norm1.y; g5 *= norm1.z; g7 *= norm1.w;
   vec4 nz = mix(vec4(dot(g0, vec3(f0.x, f0.y, f0.z)), dot(g1, vec3(f1.x, f0.y, f0.z)),
                      dot(g2, vec3(f0.x, f1.y, f0.z)), dot(g3, vec3(f1.x, f1.y, f0.z))),
                 vec4(dot(g4, vec3(f0.x, f0.y, f1.z)), dot(g5, vec3(f1.x, f0.y, f1.z)),
                      dot(g6, vec3(f0.x, f1.y, f1.z)), dot(g7, vec3(f1.x, f1.y, f1.z))), f.z);
   return 2.2 * mix(mix(nz.x,nz.z,f.y), mix(nz.y,nz.w,f.y), f.x);
}

   // Compute intersection of a ray with a sphere, if any.  Return t.
   // If there is no intersection, return 10000.

   float raySphere(vec3 V, vec3 W, vec4 S) {

      // YOU NEED TO COMPUTE t, BY SETTING UP AND THEN SOLVING A QUADRATIC EQUATION.
	  float b = 2.*dot(W, V-S.xyz); 
	  float c = dot(V-S.xyz, V-S.xyz) - S.w*S.w;
	  float d = b*b - 4.*c;
	  if(d > 0.){
		  return (-b - sqrt(d))/2.;
	  }
	  else
      	  return 10000.;
   }

   vec2 raySphere2(vec3 V, vec3 W, vec4 S){
	  float b = 2.*dot(W, V-S.xyz); 
	  float c = dot(V-S.xyz, V-S.xyz) - S.w*S.w;
	  float d = b*b - 4.*c;
	  if(d > 0.){
		  return vec2((-b - sqrt(d))/2., (-b + sqrt(d))/2.);
	  }
	  else
      	  return vec2(10000., 10000.);
   }

	float rayPlane(vec3 V, vec3 W, vec4 P){
		float t = -(dot(V, P.xyz) + P.w)/dot(W, P.xyz);
		if(t > 0.){
			return t;
		}
		else{
		    return 10000.;
		}
	}

    vec3 shadePlane(vec3 point, vec4 plane, vec3 material) {
	  float t= dot(Ldir, plane.xyz);
	  vec3 color = (0.2 +  max(0., .8*t)) * material;
	  return color;
	}

   vec3 refracDir(vec3 W, vec3 point, vec3 normal, float refracRate){
	  float WN = dot(W, normal);
	  if(WN < 0.){
		  float s1 = sqrt(1. - WN*WN);
		  float s2 = s1 * refracRate;
		  float c2 = sqrt(1. - s2*s2);
		  vec3 v = refracRate*(W - WN * normal);
		  vec3 u = c2 * -normal;
		  return u + v;
	  }
	  else{
		  float s2 = sqrt(1. - WN*WN);
		  float s1 = s2 / refracRate;
		  if(s1 > 1.){
			return vec3(10000., 0., 0.);
		  }
		  float c1 = sqrt(1. - s1*s1);
		  vec3 v = (W - WN * normal)/refracRate;
		  vec3 u = c1 * normal;
		  return u + v;
	  }
   }

   vec3 reflectionDir(vec3 W, vec3 normal){
	 return 2.*max(0., dot(-W, normal))*normal + W;
   }

   bool refracSphere(vec3 W, vec3 point, vec4 S, float refracRate){
	  vec3 normal = (point - S.xyz)/S.w;
	  vec3 dir = refracDir(W, point, normal, refracRate);
	  if(dir.x >= 10000.){
		outPoint = point;
		outDir = reflectionDir(W, normal);
		return false;
	  }
	  vec2 t = raySphere2(point, dir, S);
	  outPoint = point + t.y * dir;
	  normal = (outPoint - S.xyz)/S.w;
	  outDir = refracDir(dir, outPoint, normal, refracRate);
	  return true;
   }

  bool refraction(vec3 V, vec3 W){
	  float t = 10000.;
	  outT = 10000.;
	  bool result = false;
	  for(int i = 0; i < tranSphereNum; i++){
	      float tt = raySphere(V , W, uTranSphere[i]);
		  if(tt < t && tt > 0.001){
			  result = true;
			  refracSphere(W, V + tt*W, uTranSphere[i], refracRate);
		      t = tt;
			  outT = tt;
		  }
	  }
	  return result;
   }

   bool rayTracing(vec3 V, vec3 W){
	  float t = 10000.;
	  bool result = false;

	  for(int i = 0; i < planeNum; i++){
	    float tt = rayPlane(V, W, plane[i]);
		if(tt < t && tt > 0.001){
			  result = true;
			  rtMaterial = materialPlane[i];
			  rtPoint    = V + tt*W;
			  rtNormal   = plane[i].xyz;
			  t = tt;
		}
	  }
	  
	  for(int i = 0; i < sphereNum; i++){
	      float tt = raySphere(V , W, uSphere[i]);
		  if(tt < t && tt > 0.001){
			  result = true;
			  rtMaterial = materialSphere[i];
			  rtPoint    = V + tt*W;
			  rtNormal   = (rtPoint - uSphere[i].xyz)/uSphere[i].w;
		      t = tt;
		  }
	  }

	  vec2 t0 = vec2(-10000., 10000.);
	  int cnt = 0;
	  vec3 material;
	  vec3 point;
	  vec3 normal;
	  for(int i = 0; i < interSphereNum; i++){
	  	  vec2 t1 = raySphere2(V, W, uInterSphere[i]);
	  	  if(max(t0.x, t1.x) < min(t0.y, t1.y)){
	  		  if(t1.x > t0.x){
			  	  material = uInterSphereMatreal;
			  	  point    = V + t1.x*W;
			  	  normal   = (point - uInterSphere[i].xyz)/uInterSphere[i].w;
	  		  }
			  t0.x = max(t0.x, t1.x);
			  t0.y = min(t0.y, t1.y);
			  cnt++;
		  }
	  }
	  if(cnt == interSphereNum && t0.x > 0.001 && t0.x < t){
			t = t0.x;
			rtMaterial = material;
			rtPoint    = point;
			rtNormal   = normal;
			result = true;
	  }
	  rtT = t;
	  return result;
   }

   bool shadow(vec3 point, vec3 normal){
	  vec3 V = point; //+ 0.1*(point - sphere.xyz); // why does this not work?
	  vec3 W = Ldir;
      return rayTracing(V, W) || refraction(V, W);
   }

   float diffusion(vec3 point, vec3 normal){
	  return max(0., dot(Ldir, normal));
   }

   float phongReflection(vec3 W, vec3 point, vec3 normal){
	  vec3 R = 2.*max(0., dot(Ldir, normal))*normal - Ldir;
	  return pow(dot(R, W), 20.);
   }


   vec3 reflection(vec3 WW, vec3 point, vec3 normal){
	  vec3 W = -WW;
      vec3 R = 2.*max(0., dot(W, normal))*normal - W;
	  vec3 V = point;
      vec3 color = vec3(0., 0., 0.);
	  if(rayTracing(V, R)){
		  color = rtMaterial;
	  }
	  if(refraction(V, R)){
		if(rtT > outT)
			if(rayTracing(outPoint, outDir))
				color = rtMaterial;
	  }
	  return color;
   }

   // Diffusely shade a sphere.
   //    point is the x,y,z position of the surface point.
   //    sphere is the x,y,z,r definition of the sphere.
   //    material is the r,g,b color of the sphere.

   vec3 shade(vec3 W, vec3 point, vec3 normal, vec3 material){
      vec3 color = vec3(0.,0.,0.);
	  color = .1*material;
	  float d = diffusion(point, normal);
      float rlf = phongReflection(W, point, normal);
	  if(!shadow(point, normal)){
		vec3 light = .9 * vec3(1., 1., 1.);
	  	color += (.3*rlf + .5*d) * material * light;
	  }
 	  color += .2 * .5 * d * reflection(W, point, normal) * material;
      return color;
   }

   void main(void) {
      vec2 c = uCursor.xy;

      //Lrgb = vec3(1.,.5,0.);
      Ldir = normalize(vec3(c.x, c.y, 1. - 2. * dot(c, c)));
      //Ldir = normalize(vec3(1., 1., 1.));

      // YOU NEED TO COMPUTE V AND W TO CREATE THE RAY FOR THIS PIXEL,
      // USING vPosition.x AND vPosition.y.

      vec3 V, W;

	  V = vec3(0., 0., uF);
	  W = normalize(vPosition - V);

	  materialPlane[0] = vec3(0., 0., 1.);
	  plane[0] = vec4(0., 0., 1., 50.);


      // YOU NEED TO SET r,g,b FOR material.
	  materialSphere[0] = vec3(1., 1., 0.);
	  //materialSphere[1] = vec3(0., 1., 1.);
	  uInterSphereMatreal = vec3(1., 0., 1.);

	  vec3 color = vec3(0., 0., 0.);
	  float t = 10000.;
      if(rayTracing(V, W)){
			t = rtT;
   	      	color = shade(W, rtPoint, rtNormal, rtMaterial);
	  }
	  if(refraction(V, W)){
		if(outT < t){
			if(rayTracing(outPoint, outDir)){
   	      		color = shade(outDir, outPoint, rtNormal, rtMaterial);
		   }
		}
	  }

      gl_FragColor = vec4(sqrt(color), 1.); // Do Gamma correction.
   }
</script>

<script>
start_gl('canvas1', document.getElementById('my_vertex_shader'  ).innerHTML,
                    document.getElementById('my_fragment_shader').innerHTML);
</script>

  </body>
</html>

